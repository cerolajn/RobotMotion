{"version":3,"sources":["../../Algorithm/Algorithm.js"],"names":["Algorithm","xStartPoint","yStartPoint","xEndPoint","yEndPoint","populationN","searchSpace","bGroupPosition","bGroupFitValue","loopNValue","finalIValue","pC1","sC2","positionResultsArray","group_member","nComp","push","mPCoordinates","mBPCoordinates","mVCoordinates","mFitValue","mBFitValue","spaceComp","Math","random","FitnessFunction","gComp","length","loopIter","vComp","max","min","resultConverted","PointToPixelConverter","convertedInitPoint","unshift","convertedTargPoint","current_pCoordinates","getArrayColumn","setArray","Column","map","x","positionArray","convertedArray","xColumn","xMin","apply","xMax","xDistance","yColumn","yMin","yMax","yDistance","i","parseFloat","toFixed"],"mappings":"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","file":"Algorithm.js","sourcesContent":["\r\n/*INITIAL INPUTS*/\r\n//ObjectiveFunction\r\n//Number of iterations\r\n//Number of population(size)\r\n//Search space - dimension,2 unknown variables : x and y\r\n//Inertia\r\n//w =1 (inertia weight)\r\n//wdamp = 0.98 (dumping inertia )\r\n//Coefficients\r\n//c1=1.5 (Personal Acceleration Coefficient )\r\n//c2=1.5 (Social Acceleration Coefficient)\r\n/*-----------------------------------------------------------*/\r\n\r\n\r\n/*ALGORITHM STEPS ( source- theory part of final project and references)\r\n1) Basic and beginning initialization  with random values of position and velocity each member of the swarm.\r\n2) Fitness function. is evaluated through all particles in swarm.\r\n3) The value obtained from the fitness function from particle i  is compare with the value of Pibest. In case that Pibest has got worse value thank evaluated value of fitness function. New value of fitness function  takes the place of Pibest.\r\n4) If the value in Pibest is better than Pgbest, then Pgbest = Pibest.\r\n5) Updating and modification velocity and position of the particles using equations.\r\n6) In case of not-reaching maximum value of iteration or particular condition was not fulfilled, the algorithm comes back to the point 2.\r\n*/\r\n/*---------------- FUNCTION DECLARATION----------------------*/\r\n\r\nfunction Algorithm(xStartPoint,yStartPoint,xEndPoint,yEndPoint) {\r\n  let populationN = 15;\r\n  // space dimension\r\n  let searchSpace = 2;\r\n  // the greatest position from all sample elements\r\n  let bGroupPosition = [];\r\n  // the greatest value of fitness in al sample elements\r\n  let bGroupFitValue = null;\r\n  // quantity of iteration\r\n  let loopNValue = 4;\r\n  // value of inertia\r\n  let finalIValue = 0.98;\r\n  // coefficient personal\r\n  let pC1 = 1.5;\r\n  // coefficient social\r\n  let sC2 = 1.5;\r\n  // array which holds obtained position\r\n  let positionResultsArray =[];\r\n  // declaration of array with elements\r\n  let group_member =[];\r\n  // creating N group members\r\n  for (let nComp = 0; nComp < populationN ; nComp++) {\r\n    group_member.push({\r\n      // member position\r\n      mPCoordinates: [],\r\n      //member best position\r\n      mBPCoordinates:[],\r\n      //member velocity\r\n      mVCoordinates: [],\r\n      //member fit value\r\n      mFitValue:  null,\r\n      //member best fit value\r\n      mBFitValue:null,\r\n    });\r\n    // initialization random coordinates of position, velocity and best value of position for each member of group\r\n    for (let spaceComp = 0; spaceComp < searchSpace; spaceComp++){\r\n      group_member[nComp].mPCoordinates.push(Math.random());\r\n      group_member[nComp].mVCoordinates.push(Math.random());\r\n      group_member[nComp].mBPCoordinates.push(group_member[nComp].mPCoordinates[spaceComp]);\r\n    }\r\n    // first setting fit value according to fitness function\r\n    group_member[nComp].mFitValue = FitnessFunction(group_member[nComp].mPCoordinates);\r\n    // checking conditions of fit value and assigning best group position\r\n    if (group_member[nComp].mFitValue < bGroupFitValue || bGroupFitValue == null ) {\r\n      bGroupFitValue = group_member[nComp].mFitValue;\r\n      bGroupPosition= [];\r\n      for (let gComp = 0; gComp < group_member[nComp].mPCoordinates.length; gComp++)\r\n        bGroupPosition.push(group_member[nComp].mPCoordinates[gComp]);\r\n    }\r\n  }\r\n  // main algorithm loop\r\n  for (let loopIter = 0;  loopIter < loopNValue; loopIter++) {\r\n    for (let nComp = 0; nComp < group_member.length; nComp++) {\r\n      for (let vComp = 0; vComp < group_member[nComp].mVCoordinates.length; vComp++) {\r\n        // assigning velocity of each group member according to formula\r\n        group_member[nComp].mVCoordinates[vComp] =\r\n          Math.max(0, Math.min(1,\r\n            (finalIValue * group_member[nComp].mVCoordinates[vComp]) +\r\n            (pC1 * Math.random() * (group_member[nComp].mBPCoordinates[vComp] - group_member[nComp].mPCoordinates[vComp])) +\r\n            (sC2 * Math.random() * (bGroupPosition[vComp] - group_member[nComp].mPCoordinates[vComp]))));\r\n        // assigning position of each group member according to formula\r\n        group_member[nComp].mPCoordinates[vComp] = Math.max(0, Math.min(1, group_member[nComp].mPCoordinates[vComp] +\r\n          group_member[nComp].mVCoordinates[vComp]));\r\n      }\r\n      // updating fitness value\r\n      group_member[nComp].mFitValue = FitnessFunction(group_member[nComp].mPCoordinates);\r\n      //assigning  best member of group position after fulfilling proper conditions\r\n      if (group_member[nComp].mFitValue < group_member[nComp].mBFitValue) {\r\n        group_member[nComp].mBFitValue = group_member[nComp].mFitValue;\r\n        group_member[nComp].mBPCoordinates = [];\r\n        for (let gComp = 0; gComp < group_member[nComp].mPCoordinates.length; gComp++){\r\n          group_member[nComp].mBPCoordinates.push(group_member[nComp].mPCoordinates[gComp]);\r\n        }\r\n      }\r\n      //assigning  best group position after fulfilling proper conditions\r\n      if (group_member[nComp].mFitValue < bGroupFitValue) {\r\n        bGroupFitValue = group_member[nComp].mFitValue;\r\n        bGroupPosition = [];\r\n        for (let gComp = 0; gComp < group_member[nComp].mPCoordinates.length; gComp++){\r\n          bGroupPosition.push(group_member[nComp].mPCoordinates[gComp]);\r\n        }\r\n      }\r\n    }\r\n    positionResultsArray.push(group_member[loopIter].mBPCoordinates);\r\n\r\n\r\n  }\r\n  let resultConverted;\r\n  resultConverted= PointToPixelConverter(positionResultsArray);\r\n\r\n  let convertedInitPoint = [];\r\n  convertedInitPoint.push(xStartPoint,yStartPoint);\r\n  resultConverted.unshift(convertedInitPoint);\r\n\r\n  let convertedTargPoint = [];\r\n  convertedTargPoint.push(xEndPoint,yEndPoint);\r\n  resultConverted.push(convertedTargPoint);\r\n\r\n\r\n  return resultConverted;\r\n}\r\n\r\n/**\r\n * @return {number}\r\n */\r\nfunction FitnessFunction(current_pCoordinates){\r\n  return (current_pCoordinates[0] * current_pCoordinates[0])+ (current_pCoordinates[1] * current_pCoordinates[1])\r\n}\r\n\r\nfunction getArrayColumn(setArray, Column) {\r\n  return setArray.map(x => x[Column]);\r\n}\r\n\r\nfunction PointToPixelConverter(positionArray) {\r\n  let convertedArray = [];\r\n  //calculating distance between all x coordinates in array\r\n  let xColumn = getArrayColumn(positionArray, 0);\r\n  let xMin;\r\n  xMin = Math.min.apply(null, xColumn);\r\n  let xMax;\r\n  xMax = Math.max.apply(null, xColumn);\r\n  //width\r\n  let xDistance;\r\n  xDistance = xMax - xMin;\r\n  //Calculating distance between all y coordinates in array\r\n  let yColumn = getArrayColumn(positionArray, 1);\r\n  let yMin;\r\n  yMin = Math.min.apply(null, yColumn);\r\n  let yMax;\r\n  yMax = Math.max.apply(null, yColumn);\r\n  //height\r\n  let yDistance;\r\n  yDistance = yMax - yMin;\r\n  // Changing points to pixel\r\n  for (let i = 0; i < positionArray.length; ++i) {\r\n\r\n    positionArray[i][0] = ((positionArray[i][0] - xMin) / xDistance) * 800;\r\n    positionArray[i][0] = parseFloat(positionArray[i][0].toFixed());\r\n    positionArray[i][1] = ((positionArray[i][1] - yMin) / yDistance) * 600;\r\n    positionArray[i][1] = parseFloat(positionArray[i][1].toFixed());\r\n    convertedArray.push([positionArray[i][0], positionArray[i][1]]);\r\n\r\n  }\r\n  return convertedArray;\r\n}\r\n\r\n\r\n\r\n"]}